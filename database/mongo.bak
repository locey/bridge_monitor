package database

import (
	"context"
	"sync"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
    "github.com/sirupsen/logrus"
)

type Meson struct {
	ReqID     string  `bson:"reqid"`
	ChainA    string  `bson:"chain_a"`
	ChainB    string  `bson:"chain_b"`
	Timestamp int64   `bson:"timestamp"`
	AmountA   float64 `bson:"amount_a"`
	AmountB   float64 `bson:"amount_b"`
	ActionA   string  `bson:"action_a"`
	ActionB   string  `bson:"action_b"`
	TxHashA   string  `bson:"tx_hash_a"`
	TxHashB   string  `bson:"tx_hash_b"`
	IsCheck   bool    `bson:"is_check"`
}

var (
	clientInstance *mongo.Client
	clientOnce     sync.Once
	clientLock     sync.Mutex
)

const (
	dbURI  = "mongodb://localhost:27017"
	dbName = "bridge-monitor"
)

// Connect 初始化一个 MongoDB 客户端实例
func Connect() *mongo.Client {
	clientLock.Lock()
	defer clientLock.Unlock()

	if clientInstance == nil {
		// 设置客户端选项
		clientOptions := options.Client().ApplyURI(dbURI)
		// 连接到 MongoDB
		client, err := mongo.Connect(context.TODO(), clientOptions)
		if err != nil {
			logrus.Fatalf("Failed to connect to MongoDB: %v", err)
		}

		// 检查连接
		err = client.Ping(context.TODO(), nil)
		if err != nil {
			logrus.Fatalf("Failed to ping MongoDB: %v", err)
		}
		logrus.Println("Connected to MongoDB!")

		clientInstance = client
	}

	return clientInstance
}

// Disconnect 关闭 MongoDB 客户端连接
func Disconnect() {
	clientLock.Lock()
	defer clientLock.Unlock()

	if clientInstance != nil {
		// 断开与 MongoDB 的连接
		err := clientInstance.Disconnect(context.TODO())
		if err != nil {
			logrus.Fatalf("Failed to disconnect from MongoDB: %v", err)
		}
		clientInstance = nil
		logrus.Println("Disconnected from MongoDB.")
	}
}

// GetDatabase 返回一个 MongoDB 数据库实例
func GetDatabase() *mongo.Database {
	client := Connect() // 获取 MongoDB 客户端实例
	return client.Database(dbName) // 返回指定名称的数据库实例
}

// InitDatabase 初始化数据库
func InitDatabase() {
	database := GetDatabase() // 获取数据库实例

	// 检查集合是否存在
	collections, err := database.ListCollectionNames(context.TODO(), bson.M{"name": "meson"})
	if err != nil {
		logrus.Fatal(err) // 如果查询集合名称失败，记录错误并退出
	}

	if len(collections) == 0 {
		// 如果集合 "meson" 不存在，则创建该集合
		logrus.Println("Collection 'meson' does not exist. Creating collection...")

		// 创建集合
		err = database.CreateCollection(context.TODO(), "meson")
		if err != nil {
			logrus.Fatal(err) // 如果创建集合失败，记录错误并退出
		}
		logrus.Println("Collection 'meson' created.")
	}

	// 检查是否存在 reqid 的唯一索引
	indexes, err := database.Collection("meson").Indexes().List(context.TODO())
	if err != nil {
		logrus.Fatal(err) // 如果查询索引列表失败，记录错误并退出
	}

	var indexExists bool
	for indexes.Next(context.TODO()) {
		var index bson.M
		if err := indexes.Decode(&index); err != nil {
			logrus.Fatal(err) // 如果解码索引文档失败，记录错误并退出
		}

		if index["name"] == "reqid_1" {
			indexExists = true // 如果存在名为 "reqid_1" 的索引，设置标志位
			break
		}
	}

	if !indexExists {
		// 如果 "reqid" 唯一索引不存在，则创建该索引
		indexModel := mongo.IndexModel{
			Keys:    bson.D{{Key: "reqid", Value: 1}}, // 索引字段
			Options: options.Index().SetUnique(true),  // 设置为唯一索引
		}
		_, err = database.Collection("meson").Indexes().CreateOne(context.TODO(), indexModel)
		if err != nil {
			logrus.Fatal(err) // 如果创建索引失败，记录错误并退出
		}
		logrus.Println("Unique index on 'reqid' created.")
	} else {
		logrus.Println("Unique index on 'reqid' already exists.") // 如果索引已存在，输出提示信息
	}
}

// FindMesonByReqID 根据 reqID 查询 Meson 文档
func FindMesonByReqID(reqID string) (*Meson, error) {
	database := GetDatabase() // 获取数据库实例
	var result Meson          // 创建一个 Meson 结构体实例来存储查询结果

	// 在 "meson" 集合中查找 reqID 匹配的文档，并将结果解码到 result 变量中
	err := database.Collection("meson").FindOne(context.TODO(), bson.M{"reqid": reqID}).Decode(&result)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			// 如果没有找到匹配的文档，返回 nil 和 nil 错误
			return nil, nil
		}
		// 如果查询过程中发生其他错误，返回 nil 和错误信息
		return nil, err
	}

	// 返回查询到的 Meson 文档和 nil 错误
	return &result, nil
}

// InsertMeson 插入 Meson 文档到 meson 集合
func InsertMeson(meson Meson) error {
	database := GetDatabase() // 获取数据库实例

	// 将 Meson 结构体实例插入到 "meson" 集合中
	result, err := database.Collection("meson").InsertOne(context.TODO(), meson)
	if err != nil {
		logrus.Errorf("Failed to insert Meson: %v", err)
		return err
	}

	// 打印插入操作结果
	logrus.Infof("Inserted Meson with ID: %v", result.InsertedID)

	// 返回插入操作的错误信息（如果有）
	return err
}

// UpdateMeson 更新 Meson 文档
func UpdateMeson(meson *Meson) error {
	database := GetDatabase() // 获取数据库实例

	// 构建用于查找文档的过滤器，根据 reqid 匹配文档
	filter := bson.M{"reqid": meson.ReqID}

	// 构建更新操作，将 Meson 结构体中的相关字段更新到文档中
	update := bson.M{
		"$set": bson.M{
			"chain_b":  meson.ChainB,   // 更新 chain_b 字段
			"amount_b": meson.AmountB,  // 更新 amount_b 字段
			"action_b": meson.ActionB,  // 更新 action_b 字段
			"tx_hash_b": meson.TxHashB, // 更新 tx_hash_b 字段
			"is_check": meson.IsCheck,  // 更新 is_check 字段
		},
	}

	// 在 "meson" 集合中查找并更新匹配的文档
	result, err := database.Collection("meson").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		logrus.Errorf("Failed to update Meson: %v", err)
		return err
	}

	// 打印更新操作结果
	logrus.Infof("Updated %v document(s)\n", result.ModifiedCount)

	// 返回更新操作的错误信息（如果有）
	return err
}

// FindUncheckedMesons 查询 is_check 为 false 的 Meson 文档
func FindUncheckedMesons() ([]Meson, error) {
	database := GetDatabase() // 获取数据库实例

	// 构建用于查找文档的过滤器，过滤条件为 is_check 字段为 false
	filter := bson.M{"is_check": false}

	// 在 "meson" 集合中查找所有匹配过滤器条件的文档
	cursor, err := database.Collection("meson").Find(context.TODO(), filter)
	if err != nil {
		// 如果查询失败，记录错误并返回 nil 和错误信息
		logrus.Errorf("Failed to find unchecked Mesons: %v", err)
		return nil, err
	}
	defer cursor.Close(context.TODO()) // 确保在函数结束时关闭游标

	var results []Meson // 创建一个 Meson 结构体切片来存储查询结果

	// 遍历查询结果
	for cursor.Next(context.TODO()) {
		var meson Meson
		// 将当前文档解码到 Meson 结构体实例中
		err := cursor.Decode(&meson)
		if err != nil {
			// 如果解码失败，记录错误并返回 nil 和错误信息
			logrus.Errorf("Failed to decode Meson: %v", err)
			return nil, err
		}
		// 将解码后的 Meson 实例添加到结果切片中
		results = append(results, meson)
	}

	// 检查游标是否有错误
	if err := cursor.Err(); err != nil {
		// 如果游标有错误，记录错误并返回 nil 和错误信息
		logrus.Errorf("Cursor error: %v", err)
		return nil, err
	}

	// 返回查询到的 Meson 结构体切片和 nil 错误
	return results, nil
}
